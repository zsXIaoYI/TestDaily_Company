Map:
   存储键值对，键值唯一
   Hashtable:底层是哈希表，不可以存入null的键和值,线程同步 jdk 1.0 效率低
   HashMap：哈希表，允许存入null的键和值，线程不同步 jdk 1.2
   LinkedHashMap:HashMap的一个子类，它保留插入的顺序，
       如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。并允许使用null值和null键
   TreeMap：二叉树，线程不同步，可以给键排序
hashCode方法的作用:
   对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。
   在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，
   这样的散列集合包括HashSet、HashMap以及HashTable。
   为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）
   也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。
   但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。
   此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，
   实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，
   它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了
   不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，
   说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，
   这个数值称作为散列值。
   put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，
   然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。
   从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。

   如果两个对象的hashcode值不等，则必定是两个不同的对象。
   如果要判断两个对象是否真正相等，必须通过equals方法。

